# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Chunchun Ye
Student ID: 304-502-384
Email: yechunchun@ucla.edu

# Partner 2 (if you're working in a team)
Name: Kexin Yu
Student ID: 804-316-935
Email: kexinyu@ucla.edu

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)
We implemented parallelism by creating new processes with fork() in main(). 
Each child is responsible for handling a downloading task. The parent waits 
until all children finish their downloading tasks and then starts uploading.


# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)
char *strcpy(char *dest, const char *src) is a function that can cause buffer 
overflow because it may copy a file whose size exceeeds TASKBUFSIZ.
char *strncpy(char *dest, const char *src, size_t n) ensure that at most n 
bytes of src are copied.
We replaced strcpy() with strncpy() in start_download() and task_download()
to guarantee that the size of the copied file does not exceed TASKBUFSIZ.


# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)
- Pre-allocate enough space for filename and disk_filename:
    	Replace strcpy(t->filename, "") with memset(t->filename, 0, FILENAMESIZ) 
    	in task_new() to allocate a fixed size array for filename and disk_filename 
    	to avoid future buffer overflows.
	
- Check download filename legnth 
	If a download filenanme is too long, print error massage and goto "exit" 
	in start_download() or "try_again" in task_download().
	
- Check upload filename length
	If an upload filenanme is too long, print error massage and goto "exit" 
	in task_upload().

- Check each peer only serves in its current directory
	Use getcwd() to get the absolute pathname of the current working directory.
	Use realpath to get the absolute pathname of the file.
	Compare the two with strncpy(). If they are different, the peer may serve 
	files outside its current directory and so the task will be stopped.

- Limit the maximum file size for downloading
	Set the maximum file size for downloading to make sure other peers are not 
	able to monopolize the peer's resources and fill up its disk. If the size does 
	exceed the limit, the task will be rejected. 
	
- Tracker communication should not have too many peers logged in at once:
	TASKBUFSIZ is not large enough to allow many peers to be logged in at
	once, so we increased the value of TASKBUFSIZ



# Add any other information you'd like us to know below this line.
